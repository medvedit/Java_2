package ru.medwedSa.Lessen_3_Exception_Enum_Collections.ClassWork.Package_c_Wrapper_Collection;

import java.util.*;

/**
 *  Коллекции...
 *  Классы и обертки.
 *  У всех примитивов есть обертки:
 *  Примитивы: byte, short, int,    long, float, double, boolean, char      -> 8 всего.
 *  Обертки:   Byte, Short, Integer Long, Float, Double, Boolean, Character
 *  К примитиву нельзя прикрутить метод, а если использовать обертки, то функционал значительно расширяется.
 *  Далее в коде:
 *  ArrayList<Integer> array = new ArrayList<>() - пример использования напрямую обертки в коллекциях.
 *  static class Box + ArrayList<Box> boxes = new ArrayList<>() - пример использования примитива, через созданный
 *                                                                класс и уже созданный класс используется для создания
 *                                                                объекта в коллекции.
 *  <ArrayList> — реализация изменяемого массива интерфейса. В основе ArrayList лежит идея динамического массива.
 *                А именно, возможность добавлять и удалять элементы, при этом будет увеличиваться или уменьшаться
 *                по мере необходимости.
 *  <HashSet> - Обобщенный класс HashSet представляет хеш-таблицу.
 *              Он наследует свой функционал от класса <AbstractSet>, а также реализует <интерфейс Set>. Интерфейс <Set>
 *              расширяет интерфейс Collection и представляет набор уникальных элементов.
 *              Set не добавляет новых методов, только вносит изменения унаследованные.
 *              В частности, метод add() добавляет элемент в коллекцию и возвращает true,
 *              если в коллекции еще нет такого элемента.
 *  <LinkedHashSet> - Класс LinkedHashSet расширяет класс HashSet, не добавляя никаких новых методов.
 *                    Класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись.
 *                    Это позволяет организовать упорядоченную итерацию вставки в набор.
 *  <TreeSet> - создаёт коллекцию, которая для хранения элементов применяет дерево.
 *              Объекты сохраняются в отсортированном порядке по возрастанию.
 *  <Map> - Map — это структура данных, которая содержит набор пар “ключ-значение”.
 *          По своей структуре данных напоминает словарь, поэтому ее часто так и называют.
 *          В то же время, Map является интерфейсом, и
 *          в стандартном jdk содержит основные реализации: <Hashmap>, <LinkedHashMap>, <Hashtable>, <TreeMap>.
 *  <Hashmap> - Класс HashMap использует хеш-таблицу для хранения карточки,
 *              обеспечивая быстрое время выполнения запросов get() и put() при больших наборах.
 *              Класс реализует интерфейс Map (хранение данных в виде пар ключ/значение).
 *              Ключи и значения могут быть любых типов, в том числе и null. При этом все ключи обязательно должны
 *              быть уникальны, а значения могут повторяться. Данная реализация не гарантирует порядка элементов.
 */
public class Main {

    static class Box implements Comparable{ // класс объекта Box, с переменными ширина и высота
        int width;
        int height;

        Box(int width, int height) { // конструктор класса Box
            this.width = width;
            this.height = height;
        }

        @Override
        public boolean equals(Object obj) {
            if(this == obj) { return true; } // Если текущий объект равен obj.
                                             // Простым языком: если мы сравниваем Box и Box
            if(!(obj instanceof Box)) { return false; } // Если obj не является производным от класса Box
            Box other = (Box) obj; // приводим к Box входящий obj
            return other.width == width && other.height == height; // Сравниваем объекты по высоте и ширине.
                                                                   // Ищем одинаковые вхождения.
        }

        @Override // переопределил метод от класса Objects
        public String toString() {
            return String.format("Box(%d, %d)", width, height);

        }

        @Override // переопределили метод для создания одинакового хеша одинаковым Box
        public int hashCode() {
            return Objects.hash(width, height);
        }


        private int square() { return  width * height; } // создали функцию подсчета площади Box
        @Override // для сортировки в коллекции TreeSet
        public int compareTo(Object o) { // переопредели метод для того, что бы научить коллекцию TreeSet сравнивать
                                         // наши, нами созданные Box.
//            Box other = (Box) o; // Пусть входящий Object o будет наша коробка
//            int sq = square(); // площадь которую мы сравниваем сейчас
//            int oSq = other.square(); // другая площадь
//            if (sq < oSq) { return -1; } // если наша площадь меньше чем другая
//            else if (sq > oSq) { return 1; } // если наша площадь больше чем другая
//            else return 0; // в любом другом случае
            // мы - это тот объект, на котором находится сравнение, для сортировки в коллекции TreeSet
            return square() - ((Box)o).square(); // закомментированные (выше) 6 строчек кода можно сократить до одной!
        }
    }

    public static void main(String[] args) {
// .....................................................................................................................
        int i0 = 5; // по идентификатору i0 в этой строке кода и,
        i0 = 6; // по идентификатору i0 в этой строке кода НАХОДИТСЯ ОДИН ИТОТ-ЖЕ ОБЪЕКТ!
        Integer i1 = 5; // по идентификатору i1 в этой строке кода и,
        i1 = 6; // по идентификатору i1 в этой строке кода НАХОДЯТСЯ РАЗНЫЕ ОБЪЕКТЫ!

        ArrayList<Integer> array = new ArrayList<>(); // В коллекцию ArrayList нельзя положить примитив int,
                                                      // но можно Integer кроме этого появляется возможность
                                                      // пользоваться встроенным функционалом.
        array.add(5); // добавлять целые числа
        array.add(6);
        array.add(8);
        array.add(65);
        System.out.println(array.size()); // размер
        System.out.println(array.get(2)); // достать по индексу
        System.out.println(array.contains(7)); // есть ли цифра 7 в коллекции array
        System.out.println(array); // вывести все в консоль
        // .............................................................................................................
        ArrayList<Box> boxes = new ArrayList<>(); // новый пустой список для класса Box
        boxes.add(new Box(1, 3)); // добавляем в него новые объекты с шириной и высотой
        boxes.add(new Box(4, 6)); // ...
        boxes.add(new Box(5,2)); // ...
        System.out.println(boxes); // красивый вывод в консоль от метода @Override toString()
                                   // Вывод:  [Box(1, 3), Box(4, 6), Box(5, 2)]
        for (int i = 0; i < boxes.size(); i++) {
            System.out.print(boxes.get(i) + " "); // Вывод:  Box(1, 3) Box(4, 6) Box(5, 2)
        }
        System.out.println("\n");
        //..............................................................................................................
        /* Предположим, у нас есть str2 состоящая из str +(конкатенация) значения "llo", и...
         * есть ArrayList<String> strings в который положили массив значений Arrays.asList("Hello", "word")
         * будет ли сравнение strings.contains(str2) верным?
         * И тогда другой пример:
         * В классе Box создали переменную b со значением Box(1, 2), и ...
         * в классе Box создали массив box со значениями Box(2, 3), Box(4, 5), Box(1, 2)
         * сложили массив box в список boxes1 и хотим найти вхождение b в списке boxes1.
         * Очень схожие эти два примера, но !
         * Первый случай ответ: true
         * Второй случай ответ: false
         * В первом Варианте сравнения strings.contains(str2), сравнение происходит по вхождениям от класса ArrayList
         * через метод:   public boolean contains(Object o) {
         *                    return indexOf(o) >= 0;
         *                }
         * А во втором примере, мы сравниваем объекты созданные от класс Box. И т.к. созданный класс Box
         * по умолчанию extends от Object, то используется метод сравнения (equals) из класса Object,
         * а именно: @Override
         *           public boolean equals(Object obj) {
         *               return (this == obj);
         *           }
         * То-есть фактически, по умолчанию, происходит сравнение объектов boxes1 и b, а не вложений вложений в них,
         * на что и получили в ответе -> false. Для исправления этого не явного преобразования нужно в классе Box
         * переопределить метод equals из родительского класса Object,
         * дополнив его нужными нам дополнительными проверками.
         */
        String str = "He";
        String str2 = str + "llo";
        ArrayList<String> strings = new ArrayList<>(Arrays.asList("Hello", "word"));
        System.out.println(strings.contains(str2));
        // ответ: true

        Box b = new Box(1, 2);
        Box[] box = {new Box(4, 2), new Box(1, 2), new Box(1, 1)};
        ArrayList<Box> boxes1 = new ArrayList<>(Arrays.asList(box));
        System.out.println(boxes1.contains(b));
        // ответ (до переопределения метода public boolean equals(Object obj)): false
        // ответ (после переопределения метода public boolean equals(Object obj)): true
        //..............................................................................................................
        // Так-как ArrayList наследует интерфейс List, от при создании ArrayList можно писать и так..
        List<String> stringsArr = new ArrayList<>(); // Создали List<String> stringsArr от класса ArrayList<>()
        // И еще много какие классы extends от List. Всё можно увидеть в документации
        List<String> stringsLin = new LinkedList<>(); // Создали List<String> stringsLin от класса LinkedList<>()
        // Для чего нужен, чем удобнее ArrayList, LinkedList - все гуглится и читается там же..
        //..............................................................................................................
        // Рассмотрим получение hashCode():
        Box b1 = new Box(1, 2);
        Box[] box1 = {new Box(4, 2), new Box(1, 2), new Box(1, 1), b1};
        ArrayList<Box> boxes2 = new ArrayList<>(Arrays.asList(box1));
        System.out.println(b1.equals(boxes2.get(1))); // true
        System.out.println(boxes2.contains(b1)); // true
        System.out.println(b1.hashCode()); // До переопределения метода public int hashCode() -> 258952499
        System.out.println(boxes2.get(1).hashCode()); // До переопределения метода public int hashCode() -> 603742814
        // Снова не ясность - у одинаковых по-сравнению b1 и boxes2.get(1) hashCode разный
        // можно так же переопределить метод для создания одинакового hashCode одинаковым объектам.
        // Сделаем это поле небольшого примера с коллекцией HashSet.
        // HashSet - коллекции которые хранят в себе только уникальные элементы. Но т.к. эта коллекция хранить в себе
        // уникальность по хеш кодам, в коде ниже уникальность ломается, от части.. Из кода выше видно, сто элементы
        // одинаковы, а хеш разный. И ка итог:
        HashSet<Box> set = new HashSet<>(Arrays.asList(box1));
        System.out.println(set); // [Box(1, 2), Box(4, 2), Box(1, 1), Box(1, 2)] -> нет уникальности.
        System.out.print("Перебираем весь список: ");
        Iterator<Box> i = set.iterator();
        while (i.hasNext()) // пока есть следующий элемент
            System.out.print(i.next() + " "); // Перебираем весь список: Box(1, 1) Box(1, 2) Box(4, 2)
        // Далее переопределяем метод в классе Box для решения этого, и получаем:
        System.out.println("\n" + b1.hashCode()); // После переопределения метода public int hashCode() -> 994
        System.out.println(boxes2.get(1).hashCode()); // После переопределения метода public int hashCode() -> 994
        System.out.println(set); // [Box(1, 1), Box(1, 2), Box(4, 2)] и тут остались только уникальные значения.
        // Как видно из кода выше, нам получилось создать уникальность хранящихся элементов, но... Но нарушается
        // последовательность вывода хранения и вывода элементов находящихся в HashSet, т.к. последовательность вывода
        // коллекции складывается относительно вычисленного хеш кода.
        // Есть коллекция
        Set<Box> set1 = new LinkedHashSet<>(Arrays.asList(box1));
        System.out.println(set1); // [Box(4, 2), Box(1, 2), Box(1, 1)] тут сохранилась уникальность и
                                  // начальная последовательность входящих данных.
        // Класс TreeSet создаёт коллекцию, которая для хранения элементов применяет дерево.
        // Объекты сохраняются в отсортированном порядке по возрастанию. Строки по алфавиту, числа по возрастанию.
        TreeSet<Box> treeSet = new TreeSet<>(Arrays.asList(box1));
        System.out.println(treeSet); // Если запустить код сразу, не добавляя ничего в класс Box, то хоть и TreeSet
                                     // по умолчанию, все хранящее в себе и сортирует, но сортирует только то,
                                     // что знает как сортировать. А как сортировать коробки, он не знает. По-этому,
                                     // при запуске без добавления implements Comparable в класс Box - получим исключение.
        // После создания  @Override // для сортировки в коллекции TreeSet
        //                 public int compareTo(Object o)
        // И все будет отсортировано!
        // Итог: [Box(1, 1), Box(1, 2), Box(4, 2)]
        //
        // Далее коснемся HashMap. Набор пал ключ-значение. Ключ всегда уникален.
        // Каждый ключ в HashMap храниться по значению hashCode, поэтому и хранение и вывод данных может быть
        // отличен от очередности занесения данных в HashMap.
        Map<String, Integer> map = new HashMap<>();
        map.put("Январь", 1);
        map.put("Февраль", 2);
        map.put("Март", 3);
        map.put("Апрель", 4);
        map.put("Май", 5);
        System.out.println(map); // {Январь=1, Апрель=4, Март=3, Май=5, Февраль=2}
        map.put("Февраль", 10); // заменили значение у ключа "Февраль"
        System.out.println(map); // {Январь=1, Апрель=4, Март=3, Май=5, Февраль=10}
    }
}
