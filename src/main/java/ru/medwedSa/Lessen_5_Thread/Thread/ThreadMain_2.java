package ru.medwedSa.Lessen_5_Thread.Thread;

/**
 *  Решение с созданием потоков + .join(), ожидание выполнения потоков.
 *  Допустим , задача обработки объёма информации. Для ускорения процесса выполнения,
 *  общая задача делиться на четыре части. Каждая часть отдается на выполнение одному из потоков.
 *  Каждый поток решает задачу определенное количество времени. Все потоки решают задачи параллельно.
 *  И что бы в конце получить общее решение от всех потоков одним общим файлом, необходимо дождаться (.join())
 *  завершения выполнения всех задач, из всех потоков. Затем "склеить" полученные результаты в единое целое и
 *  выкатить результат.
 *  В этом примере за ожидание решений всех потоков отвечает цикл try...catch в методе main. Если его закомментировать
 *  и запустить код без него, станет наглядно видно появившуюся проблему.
 */
public class ThreadMain_2 {
    static class MyThread_2 extends Thread{ // Класс для создания потоков.
        int sleep; // Переменная принимающая задержку в мил сек на решение задачи для каждого из потоков.
        MyThread_2(String name, int sleep) { // конструктор класса.
            super(name);
            this.sleep = sleep;
        }

        @Override
        public void run() { // Переопределенный метод.
            while (!isInterrupted()) { // пока не прерван.
                try {
                    sleep(sleep); // время на задержку (выполнение).
                    System.out.println("Finish " + Thread.currentThread().getName()); // Лог в консоль о том,
                                                                                  // какой именно поток закончил работу.
                    interrupt(); // Прерван.
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
    public static void main(String[] args) {
        System.out.println("Начало работы. Деление выполнения задачи на потоки."); // Начало работы.
                                                                                   // Отданная задача на решение.
        MyThread_2 mt1 = new MyThread_2("Поток_1", 1000); // Создание потока.
        MyThread_2 mt2 = new MyThread_2("Поток_3", 3000); // Создание потока.
        MyThread_2 mt3 = new MyThread_2("Поток_4", 4000); // Создание потока.
        MyThread_2 mt4 = new MyThread_2("Поток_2", 2000); // Создание потока.
        mt1.start(); // Запуск потока.
        mt2.start(); // Запуск потока.
        mt3.start(); // Запуск потока.
        mt4.start(); // Запуск потока.
        try {
            mt1.join(); // Ожидание выполнения задачи потоком.
            mt2.join(); // Ожидание выполнения задачи потоком.
            mt3.join(); // Ожидание выполнения задачи потоком.
            mt4.join(); // Ожидание выполнения задачи потоком.
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        System.out.println("Вывод результата работы после выполнения их в потоках."); // Вывод конечного решения.
    }
}
